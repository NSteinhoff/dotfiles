# vim: ft=sh

NC='\033[0m' # No Color
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'

# List tasks etc. found in a 'tasks' file in the current directory
list_tasks() {
    [ -f tasks ] || return

    tasks=$(grep -e '^\[ \] .*' tasks)
    notes=$(grep -e '^!!! .*' tasks)
    questions=$(grep -e '^??? .*' tasks)

    if [[ -n "$tasks" ]] || [[ -n "$notes" ]]; then
        echo "---"

        if [[ -n "$tasks" ]]; then
            echo -en "$ORANGE"
            echo -e "$tasks"
            echo -en "$NC"
        fi

        if [[ -n "$notes" ]]; then
            echo -e "$notes"
        fi

        if [[ -n "$questions" ]]; then
            echo -en "$GREEN"
            echo -e "$questions"
            echo -en "$NC"
        fi
        echo "---"
    fi
}
export -f list_tasks

find_repos() {
    find . -maxdepth $1 -path '*/.git' -exec dirname {} \;
}
export -f find_repos

repo_stats() {
    pushd $1 > /dev/null
    branch_name=$(git rev-parse --abbrev-ref HEAD)
    last_commit=$(git log -n 1 --pretty=format:'%an %ar')
    echo "$(printf '\t%-30s' $1) [$branch_name] $last_commit"
    git status --short
    popd > /dev/null
}
export -f repo_stats

repo_status() {
    echo "===Status==="
    git log -n 1
    [[ -n $(git status --short) ]] && echo && git status --short
    [[ -n $(git diff) ]] && echo && git diff --stat
}
export -f repo_status

repo_activity() {
    since="${2:-two weeks ago}"
    repo="$1"
    pushd $repo > /dev/null

    if [[ -n $(git log --since="$since") ]]; then
        log=$(git log -n 1 --pretty=format:'%an	%ar')
        author=$(echo "$log" | cut -f1)
        time_ago=$(echo "$log" | cut -f2)
        if [[ "$author" == "$(git config --get user.name)" ]]; then
            dirty=""
            [[ -n $(git status --short) ]] && dirty='!!!'
            printf '\t%-30s%20s %s\n' "$repo" "$time_ago" "$dirty"
        fi
    fi

    popd > /dev/null
}
export -f repo_activity

summarize_repos() {
    depth="${1:-2}"
    echo "===Repositories==="
    find_repos $depth | parallel -k repo_stats
}
export -f summarize_repos

recent_activity() {
    activity=$(find_repos 3 | parallel -k repo_activity)
    [ -z "$activity" ] || (echo "===Activity===" && echo -e "\n$activity\n")
}
export -f recent_activity

man_page_of_the_day() {
    echo "===Man Page of the Day==="
    whatis -s1 -w '*' | shuf -n1 | xargs -0 printf '\n\t%s\n'
}

git_unstaged_changes() {
    [ -n "$(git diff --shortstat 2> /dev/null | tail -n1)" ]
}

git_uncommitted_changes() {
    [ -n "$(git diff --shortstat --staged 2> /dev/null | tail -n1)" ]
}

branch_name() {
    # git rev-parse --abbrev-ref HEAD 2> /dev/null
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

remote_branch() {
    remote=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null) && echo -n "$remote" || echo -n ""
}

branch_status() {
    ahead=$(git status | sed '/ahead/!d')
    behind=$(git status | sed '/behind/!d')
    diverged=$(git status | sed '/diverged/!d')

    if [ -n "$diverged" ]; then
        echo -n "Y"
    elif [ -n "$ahead" ]; then
        echo -n "+"
    elif [ -n "$behind" ]; then
        echo -n "-"
    else
        echo -n "*"
    fi
}

git_branch_indicator() {
    branch=$(branch_name)
    [ -n "$branch" ] || exit 0

    remote=$(remote_branch)
    if [ -n "$remote" ]; then
        remote_name="${remote#*/}"
        status="$(branch_status)"
        if [ "$remote_name" = "$branch" ]; then
            remote_indicator="->$status"
        else
            remote_indicator="->$remote$status"
        fi
    else
        remote_indicator=''
    fi

    if $(git_unstaged_changes); then
        COLOR="${RED}"
    elif $(git_uncommitted_changes); then
        COLOR="${ORANGE}"
    else
        COLOR="${GREEN}"
    fi

    echo -n "["
    echo -en "\001${COLOR}\002"
    echo -n "${branch}"
    echo -en "\001${NC}\002"
    echo -n "${remote_indicator}"
    echo -n "]"
}

tmux_indicator() {
    if [[ -n "${TMUX}" ]]; then
        echo -en "[${GREEN}TMUX${NC}] "
    fi
}

# fff file manager with CD on exit
f() {
    (command -v fff &>/dev/null) || return 1
    fff "$@"
    cd "$(cat "${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d")"
}

# Greet the user
#
# This is meant to be run when starting a shell or when coming $HOME
greeting() {
    [ -x "$(command -v ufetch)" ] && ufetch
    man_page_of_the_day
    recent_activity
    list_tasks
}
